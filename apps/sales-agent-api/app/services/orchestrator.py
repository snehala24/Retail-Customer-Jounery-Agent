# app/services/orchestrator.py

import logging, time, traceback
from app.services import tool_router

logger = logging.getLogger("orchestrator")

async def execute_plan(plan: dict, session_id: str, session: dict):
    """
    Execute tool calls based on the plan generated by the LLM.
    Logs tool execution time and resolves tool dependencies.
    """
    import re
    from app.services.metrics_tracker import metrics_tracker
    tool_calls = plan.get("tool_calls", [])
    results = []

    logger.info(f"üß† Orchestrator: Executing {len(tool_calls)} tool(s) for session {session_id}")

    def resolve_placeholders(arg_value: str):
        """Replace ${tool_results[x].result...} placeholders with real data."""
        if isinstance(arg_value, str) and arg_value.startswith("${") and "tool_results" in arg_value:
            try:
                match = re.search(r"tool_results\[(\d+)\]\.result\.(.+)\}", arg_value)
                if match:
                    index = int(match.group(1))
                    path = match.group(2).split(".")
                    ref = results[index]["result"]
                    for key in path:
                        if key.endswith("]"):
                            k, i = key[:-1].split("[")
                            ref = ref[k][int(i)]
                        else:
                            ref = ref[key]
                    return ref
            except Exception as e:
                logger.warning(f"‚ö†Ô∏è Failed to resolve placeholder {arg_value}: {e}")
        return arg_value

    for idx, call in enumerate(tool_calls):
        tool_name = call.get("tool")
        args = call.get("args", {})

        resolved_args = {k: resolve_placeholders(v) for k, v in args.items()}
        start_time = time.time()
        logger.info(f"‚öôÔ∏è Tool [{idx}] ‚Üí {tool_name} | Args: {resolved_args}")

        try:
            result = await tool_router.execute(tool_name, resolved_args)
            elapsed = round(time.time() - start_time, 3)
            logger.info(f"‚úÖ Tool [{tool_name}] succeeded in {elapsed}s | Result: {str(result)[:200]}")

            await metrics_tracker.update(tool_name, success=True, exec_time=elapsed)

            results.append({
                "tool": tool_name,
                "result": result,
                "error": None,
                "execution_time": elapsed
            })

            session["messages"].append({
                "role": "tool",
                "tool_name": tool_name,
                "args": resolved_args,
                "result": result
            })

        except Exception as e:
            elapsed = round(time.time() - start_time, 3)
            logger.error(f"‚ùå Tool [{tool_name}] failed in {elapsed}s | Error: {e}")

            await metrics_tracker.update(tool_name, success=False, exec_time=elapsed)

            results.append({
                "tool": tool_name,
                "result": None,
                "error": str(e),
                "execution_time": elapsed
            })

    logger.info(f"üìä Tool execution summary for session {session_id}: {results}")

    return {
        "reply_text": plan.get("reply_text", ""),
        "tool_results": results
    }
